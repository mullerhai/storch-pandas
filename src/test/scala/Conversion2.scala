///*
// * storch -- Data frames for Java
// * Copyright (c) 2014, 2015 IBM Corp.
// *
// * This program is free software: you can redistribute it and/or modify
// * it under the terms of the GNU General Public License as published by
// * the Free Software Foundation, either version 3 of the License, or
// * (at your option) any later version.
// *
// * This program is distributed in the hope that it will be useful,
// * but WITHOUT ANY WARRANTY; without even the implied warranty of
// * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// * GNU General Public License for more details.
// *
// * You should have received a copy of the GNU General Public License
// * along with this program.  If not, see <http://www.gnu.org/licenses/>.
// */
//package torch.pandas.operate
//
//import java.text.DateFormat
//import java.text.ParsePosition
//import java.text.SimpleDateFormat
//import java.util
//import java.util.Date
//import torch.DataFrame
//import torch.DataFrame.Function
//import torch.DataFrame.NumberDefault
//import torch.DataFrame.NumberDefault.{DOUBLE_DEFAULT, LONG_DEFAULT}
//
//import scala.collection.mutable
//import scala.collection.mutable.{LinkedHashMap, ListBuffer}
//import scala.util.control.Breaks.{break, breakable}
//
//object Conversion2 {
//  protected var dummyVariableMaxLen = 8
//
//  def getDummyVariableMaxLen: Int = dummyVariableMaxLen
//
//  /**
//   * Set the Max length of dummy part (after the $ sign) of the
//   * column (variable) names generated by <pre>toModelMatrix</pre>
//   * Observe that the final name can actually become longer to
//   * avoid non-unique variable names which is a requirement
//   *
//   * @param dummyVariableMaxLen set to negative value for no limit
//   */
//  def setDummyVariableMaxLen(dummyVariableMaxLen: Int): Unit = {
//    Conversion2.dummyVariableMaxLen = dummyVariableMaxLen
//  }
//
//  def convert[V](df: DataFrame[V]): Unit = {
//    convert(df, NumberDefault.LONG_DEFAULT, null)
//  }
//
//  def convert[V](df: DataFrame[V], numDefault: DataFrame.NumberDefault, naString: String): Unit = {
//    val conversions = new LinkedHashMap[Int, DataFrame.Function[V, ?]]
//    var converters:  Seq[DataFrame.Function[V, ?]] = null
//    val rows = df.length
//    val cols = df.size
//    numDefault match {
//      case LONG_DEFAULT =>
//        converters = List[DataFrame.Function[V, ?]](new Conversion2.LongConversion[V], new Conversion2.DoubleConversion[V], new Conversion2.BooleanConversion[V], new Conversion2.DateTimeConversion[V])
//      case DOUBLE_DEFAULT =>
//        converters = List[DataFrame.Function[V, ?]](new Conversion2.DoubleConversion[V], new Conversion2.LongConversion[V], new Conversion2.BooleanConversion[V], new Conversion2.DateTimeConversion[V])
//      case _ =>
//        throw new IllegalArgumentException("Number default contains an Illegal value")
//    }
//    val naConverter = new Conversion2.NAConversion[V](naString)
//    // find conversions
//    for (c <- 0 until cols) {
//
//      breakable{
//        for (conv <- converters) {
//          var all = true
//          breakable {
//            for (r <- 0 until rows) {
//              if (conv.apply(df.get(r, c)) == null && naConverter.apply(df.get(r, c)) != null) {
//                all = false
//                break //todo: break is not supported
//              }
//            }
//          }
//
//          if (all) {
//            conversions.put(c, conv)
//            break //todo: break is not supported
//          }
//        }
//      }
//
//    }
//    // apply conversions
//    convert(df, conversions, naString)
//  }
//
//  @SafeVarargs def convert[V](df: DataFrame[V], columnTypes: Class[? <: V]*): Unit = {
//    val conversions = new LinkedHashMap[Int, DataFrame.Function[V, ?]]
//    for (i <- 0 until columnTypes.length) {
//      val cls = columnTypes(i)
//      if (cls != null) {
//        var conv: DataFrame.Function[V, _] = null
//        if (classOf[Date].isAssignableFrom(cls)) conv = new Conversion2.DateTimeConversion[V]
//        else if (classOf[Boolean].isAssignableFrom(cls)) conv = new Conversion2.BooleanConversion[V]
//        else if (classOf[Long].isAssignableFrom(cls)) conv = new Conversion2.LongConversion[V]
//        else if (classOf[Number].isAssignableFrom(cls)) conv = new Conversion2.DoubleConversion[V]
//        else if (classOf[String].isAssignableFrom(cls)) conv = new Conversion2.StringConversion[V]
//        conversions.put(i, conv)
//      }
//    }
//    convert(df, conversions, null)
//  }
//
//  @SuppressWarnings(Array("unchecked")) def convert[V](df: DataFrame[V], conversions: LinkedHashMap[Int, DataFrame.Function[V, _]], naString: String): Unit = {
//    val rows = df.length
//    val cols = df.size
//    for (c <- 0 until cols) {
//      val conv = conversions.get(c)
//      if (conv != null) for (r <- 0 until rows) {
//        df.set(r, c, conv.apply(df.get(r, c)).asInstanceOf[V])
//      }
//      else {
//        val naConverter = new Conversion2.NAConversion[V](naString)
//        for (r <- 0 until rows) {
//          df.set(r, c, naConverter.apply(df.get(r, c)).asInstanceOf[V])
//        }
//      }
//    }
//  }
//
//  def toModelMatrix[V](df: DataFrame[V], fillValue: Double): Array[Array[Double]] = toModelMatrixDataFrame(df).fillna(fillValue).toArray(classOf[Array[Array[Double]]])
//
//  def toModelMatrix[V](df: DataFrame[V], fillValue: Double, addIntercept: Boolean): Array[Array[Double]] = toModelMatrixDataFrame(df, null, addIntercept, null, null).fillna(fillValue).toArray(classOf[Array[Array[Double]]])
//
//  def toModelMatrix[V](df: DataFrame[V], fillValue: Double, template: DataFrame[AnyRef]): Array[Array[Double]] = toModelMatrixDataFrame(df, template, false, null, null).fillna(fillValue).toArray(classOf[Array[Array[Double]]])
//
//  def toModelMatrix[V](df: DataFrame[V], fillValue: Double, template: DataFrame[AnyRef], addIntercept: Boolean): Array[Array[Double]] = toModelMatrixDataFrame(df, template, addIntercept, null, null).fillna(fillValue).toArray(classOf[Array[Array[Double]]])
//
//  def toModelMatrix[V](df: DataFrame[V], fillValue: Double, template: DataFrame[AnyRef], addIntercept: Boolean, factorReferences: LinkedHashMap[String, String]): Array[Array[Double]] = toModelMatrixDataFrame(df, template, addIntercept, null, null).fillna(fillValue).toArray(classOf[Array[Array[Double]]])
//
//  def toModelMatrixDataFrame[V](df: DataFrame[V]): DataFrame[Number] = toModelMatrixDataFrame(df, null, false, null, null)
//
//  def toModelMatrixDataFrame[V](df: DataFrame[V], template: DataFrame[AnyRef], addIntercept: Boolean): DataFrame[Number] = toModelMatrixDataFrame(df, template, addIntercept, null, null)
//
//  /**
//   * Encodes the DataFrame as a model matrix, converting nominal values
//   * to dummy variables and optionally adds an intercept column. In addition
//   * it is possible to send in a Map which contains reference categories
//   * for all or a subset of the variables. The Map should contain pairs:
//   * variable => reference factor. I.e if you have a column (variable)
//   * called "color" and you want "red" to be the reference factor in that
//   * column you should put the following in the Map: Map.put("color", "red")
//   *
//   * @param df               Dataframe to be converted
//   * @param template         template DataFrame which has already been converted
//   * @param addIntercept
//   * @param factorReferences a Map of reference factor for each variable (null if none)
//   * @param naString         replaces null values in DF with this string (default if not supplied is NA)
//   * @return a new DataFrame encoded as a model matrix
//   */
//  def toModelMatrixDataFrame[V](df: DataFrame[V], template: DataFrame[AnyRef], addIntercept: Boolean, factorReferences: LinkedHashMap[String, String], naString: String): DataFrame[Number] = {
//    val newDf = new DataFrame[Number]
//    if (addIntercept) {
//      // Add an intercept column
//      newDf.add("DFMMAddedIntercept")
//      for (i <- 0 until df.length) {
//        newDf.append(List(1.0))
//      }
//    }
//    val columns = new  ListBuffer[AnyRef]()//df.columns)
//    // Now convert Nominals (String columns) to dummy variables
//    // Keep all others as is
//    val colTypes = df.types
//    for (column <- 0 until df.size) {
//      val col: Seq[?] = df.col(column)
//      val columnName = columns(column).toString
//      if (classOf[Number].isAssignableFrom(colTypes(column))) {
//        val nums = new  ListBuffer[Number]
//
//        for (num <- col) {
//          nums.append(num.asInstanceOf[Number])
//        }
//        newDf.add(columnName, nums)
//      }
//      else if (classOf[Date].isAssignableFrom(colTypes(column))) {
//        val dates = new  ListBuffer[Number]
//
//        for (date <- col) {
//          dates.append(new Double(date.asInstanceOf[Date].getTime))
//        }
//        newDf.add(columnName, dates)
//      }
//      else if (classOf[Boolean].isAssignableFrom(colTypes(column))) {
//        val bools = new  ListBuffer[Number]
//
//        for (tVal <- col) {
//          bools.append(if (tVal.asInstanceOf[Boolean]) 1.0
//          else 0.0)
//        }
//        newDf.add(columnName, bools)
//      }
//      else if (classOf[String].isAssignableFrom(colTypes(column))) {
//        val namesUsed = new mutable.HashSet[String]
//        val extra :Seq[AnyRef] = if (template != null) template.col(column)
//        else null
//        val vr = variableToDummy(col, extra, columnName, factorReferences, naString)
//        val variable = vr.col
//        var cnt = 0
//
//        for (`var` <- variable) {
//          val name = columnName + "$" + nameToValidName(vr.names({
//            cnt += 1; cnt - 1
//          }), namesUsed)
//          newDf.add(name, `var`)
//        }
//      }
//    }
//    newDf
//  }
//
//  protected def nameToValidName(string: String, namesUsed: util.Set[String]): AnyRef = {
//    var result = string.replaceAll("[^\\p{Alpha}]", "")
//    if (dummyVariableMaxLen > 0) result = result.substring(0, Math.min(result.length, dummyVariableMaxLen))
//    var tryCnt = 0
//    val tmp = result
//    while (namesUsed.contains(result)) result = tmp + {
//      tryCnt += 1; tryCnt - 1
//    }
//    namesUsed.add(result)
//    result
//  }
//
//  protected class VariableToDummyResult(private var col:  Seq[ Seq[Number]], private var names: Array[String]) {
//  }
//
//  @SuppressWarnings(Array("rawtypes", "unchecked")) protected def variableToDummy[V](colVals:  Seq[V], extra:  Seq[AnyRef], columnName: String, references: LinkedHashMap[String, String], naString: String): Conversion2.VariableToDummyResult = {
//    val result = new  ListBuffer[ Seq[Number]]
//    val col = new  ListBuffer[String]
//
//    for (value <- colVals) {
//      col.append(if (value == null) if (naString == null) "NA"
//      else naString
//      else value.toString)
//    }
//    val factors = new mutable.TreeSet[String]()//col)
//    if (extra != null) factors.addAll(new mutable.TreeSet[?](extra))
//    if (references == null || references.get(columnName) == null) factors.remove(col(col.size - 1))
//    else {
//      val ref = references.get(columnName)
//      if (!factors.remove(references.get(columnName))) throw new IllegalArgumentException("You specified '" + ref + "' as a references for '" + columnName + "' but it did not exist in this column")
//    }
//    // Convert the variable to noFactors - 1
//    // Since we have removed the reference from
//    // factors we already have the -1 so it is
//    // not needed below
//    val uniqueIter = factors.iterator
//    val names = new Array[String](factors.size)
//    for (u <- 0 until factors.size) {
//      val v = uniqueIter.next
//      names(u) = v
//      val newDummy = new  ListBuffer[Number]
//      for (i <- 0 until col.size) {
//        if (col(i) == v) newDummy.append(1.0)
//        else newDummy.append(0.0)
//      }
//      result.append(newDummy.toSeq)
//    }
//    new Conversion2.VariableToDummyResult(result.toSeq, names)
//  }
//
//  def isnull[V](df: DataFrame[V]): DataFrame[Boolean] = df.apply(new DataFrame.Function[V, Boolean]() {
//    override def apply(value: V): Boolean = return value == null
//  })
//
//  def notnull[V](df: DataFrame[V]): DataFrame[Boolean] = df.apply(new DataFrame.Function[V, Boolean]() {
//    override def apply(value: V): Boolean = return value != null
//  })
//
//  private class NAConversion[V](private val naString: String) extends DataFrame.Function[V, V] {
//    override def apply(value: V): V = if (naString != null && String.valueOf(value) == naString) then null
//    else value
//  }
//
//  final private class StringConversion[V] extends DataFrame.Function[V, String] {
//    override def apply(value: V): String = String.valueOf(value)
//  }
//
//  final private class LongConversion[V] extends DataFrame.Function[V, Long] {
//    override def apply(value: V): Long = {
//      try return new Long(String.valueOf(value))
//      catch {
//        case ignored: NumberFormatException =>
//      }
//      null
//    }
//  }
//
//  final private class DoubleConversion[V] extends DataFrame.Function[V, Double] {
//    override def apply(value: V): Double = {
//      try return new Double(String.valueOf(value))
//      catch {
//        case ignored: NumberFormatException =>
//      }
//      null
//    }
//  }
//
//  final private class BooleanConversion[V] extends DataFrame.Function[V, Boolean] {
//    override def apply(value: V): Boolean = {
//      val str = String.valueOf(value)
//      if (str.matches("t(r(u(e)?)?)?|y(e(s)?)?")) return new Boolean(true)
//      else if (str.matches("f(a(l(s(e)?)?)?)?|n(o)?")) return new Boolean(false)
//      null
//    }
//  }
//
//  final private class DateTimeConversion[V] extends DataFrame.Function[V, Date] {
//    final private val formats = List[DateFormat](new SimpleDateFormat("y-M-d'T'HH:mm:ssXXX"), new SimpleDateFormat("y-M-d'T'HH:mm:ssZZZ"), new SimpleDateFormat("y-M-d"), new SimpleDateFormat("y-M-d hh:mm a"), new SimpleDateFormat("y-M-d HH:mm"), new SimpleDateFormat("y-M-d hh:mm:ss a"), new SimpleDateFormat("y-M-d HH:mm:ss"), new SimpleDateFormat("y/M/d hh:mm:ss a"), new SimpleDateFormat("y/M/d HH:mm:ss"), new SimpleDateFormat("y/M/d hh:mm a"), new SimpleDateFormat("y/M/d HH:mm"), new SimpleDateFormat("dd-MMM-yy hh.mm.ss.SSS a"), new SimpleDateFormat("dd-MMM-yy hh.mm.ss.SSSSSSSSS a"), new SimpleDateFormat("EEE MMM dd HH:mm:ss zzz yyyy"), DateFormat.getDateTimeInstance, new SimpleDateFormat("y/M/d"), new SimpleDateFormat("M/d/y hh:mm:ss a"), new SimpleDateFormat("M/d/y HH:mm:ss"), new SimpleDateFormat("M/d/y hh:mm a"), new SimpleDateFormat("M/d/y HH:mm"), new SimpleDateFormat("M/d/y"), DateFormat.getDateInstance)
//
//    override def apply(value: V): Date = {
//      val source = String.valueOf(value)
//      val pp = new ParsePosition(0)
//
//      for (format <- formats) {
//        val dt = format.parse(source, pp)
//        if (pp.getIndex == source.length) return dt
//        pp.setIndex(0)
//        pp.setErrorIndex(-1)
//      }
//      null
//    }
//  }
//}
